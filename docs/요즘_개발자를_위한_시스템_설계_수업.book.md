# 요즘 개발자를 위한 시스템 설계 수업

## 1. 시스템 설계의 기본

분산 시스템의 각 구성 요소는 특정 작업이나 일련의 작업 모음을 처리하며,
모두 하나의 공동 목표를 달성하려고 동작한다고 볼 수 있습니다.
각 구성 요소끼리는 RPC, 메시지 전달, 이벤트 기반 통신 등을 통해 상호작용합니다.

분산 시스템을 설계 및 개발, 유지 보수하는 일은 그렇게 쉽지 않습니다.
네트워크 통신, 데이터 일관성, 가용성, 장애 허용 시스템, 보안 등 고민해야 할 것이 많기 때문입니다.

## 1.1 시스템 설계의 이해

시스템 설계는 소프트웨어 시스템의 아키텍처, 컴포넌트, 모듈, 인터페이스 및 상호 작용을 정의하여
기능적⋅비기능적 요구 사항을 채우는 과정입니다.
요구 사항을 소프트웨어 시스템의 구조, 구현, 유지 보수 방식을 설명하는 청사진(blueprint)이나
계획으로 변환하는 작업을 의미합니다.

## 1.2 시스템 설계의 다양한 유형

### 1.2.1 상위 수준의 시스템 설계

상위 수준의 시스템 설계 과정에서 고려해야 하는 사항은 다음과 같습니다.

- 시스템 아키텍처: 시스템의 전반적인 구조로, 컴포넌트 및 각 구성 요소 간 통신 방식이나 관계 등을 표현합니다.
- 데이터 흐름: 데이터가 시스템을 통해 수집되어 저장 및 처리하는 과정을 의미합니다.
- 확장성: 작업량이 증가해도 성능 저하 없이 부하를 처리할 수 있는 능력을 말합니다.
- 장애 허용 시스템: 오류가 발생해도 시스템이 제 기능을 수행할 수 있는 능력을 의미합니다.

**시스템 아키텍처**

시스템 아키텍처를 설계할 때는 다음 사항도 고려해야 합니다.
확장성, 유지 보수성, 신뢰성, 지연 시간등이 있습니다.

여러 아키텍처 옵션 중 현재 구현해야 하는 시스템 요구 사항에 가장 적합한 아키텍처를 골라야 하는 것입니다.

**장애 허용 시스템**

시스템의 일부 요소가 어떤 이유로 장애나 오류가 발생하더라도 계속해서 정상적으로 작동할 수 있는 능력을 의미합니다.

### 1.2.2 하위 수준의 상세 설계

**API**

- **일관성**: 컴포넌트, 모듈 할 것 없이 모든 구성 요소에서 API 설계가 일관성을 유지하여 누가 보더라도
  이해하고 사용하기 쉬어야 합니다.
- **유연성**: 기존 기능에 영향을 주지 않으면서 향후에 생길 변경이나 기능 확장으 대비할 수 있어야 합니다.
- **보안**: 인증, 권한 부여, 입력 유효성 검사 등을 구현하여 시스템이 허용하지 않은 무단 접근과 데이터 유출에 노출되지 않도록 합니다.
- **성능**: API의 지연 시간을 최소화하고 자원을 효율적으로 사용할 수 있도록 최적화합니다.

---

## 1.3 업계에서 시스템 설계가 갖는 중요성

1. 요구 사항에 대한 명확한 이해
2. 협업의 시너지 효과
3. 설계 검토 및 피드백

---

## 2. 분산 시스템의 속성

**데이터 쓰기 옵션**

- 직렬 동기 쓰기: 동기화 이후 클라이언트에 확인 응답을 내보냅니다.
- 직렬 비동기 쓰기: 메인 DB에 데이터를 쓰고 확인 응답을 받은 후 즉시 클라이언트에 응답을 보냅니다. 이후 다른 레플리카 두 개는
  비동기적으로 업데이트합니다.
- 병렬 비동기 쓰기: 클라이언트가 데이터베이스를 모두 동시에 업데이트하지만 모든 처리 응답을 기다리는 것이 아니라 일부 응답을 받은 후
  클라이언트에 확인 응답을 보냅니다.
- 메시징 서비스(Kafka)에 쓰기: 카프카 등 메시징 서비스에 데이터를 기록한 후 클라이언트에 바로 응답을 보냅니다.

1. 일관성
2. 가용성
3. 파티션 허용성
4. 지연 시간의 최소화
5. 내구성
6. 신뢰성
7. 장애 허용성

---

## 3. 분산 시스템의 이론과 데이터 구조

### 3.1 CAP 정리

CAP[^1] 정리에서는 일관성, 가용성, 파티션 허용성 간 균형을 이루는 것이 본질적으로 불가능하다는 점이 중요합니다.

네트워크 파티션이 발생하면 일관성과 가용성 중에서 하나를 선택해야 합니다.
다시 말해 일관성을 포기하더라도 가용성고 파티션 허용성을 챙길 것이냐(AP),
가용성을 포기하고 일관성과 파티션 허용성(CP)을 선택할 것이냐의 문제입니다.

### 3.2 PACELC 정리

PACELC 정리[^3]는 CAP 정리의 연장선에 있는 개념입니다.

Partition 시 → Availability vs. Consistency
ELSE(E) → Latency vs. Consistency

**표기법**

- PA/EL: 파티션 시 A, 평상시 L 선택
- PC/EC: 파티션 시 C, 평상시 C 선택
- PA/EC: 파티션 시 A, 평상시 C (일부 시스템)
- PC/EL: 이론상 가능하지만 드묾

#### 3.2.1 팩소스 알고리즘

팩소스 알고리즘의 핵심은 분산 시스템에서 여러 문제가 발생하더라도 하나의 값을 도출할 수 있도록 합의하는 것입니다.
팩소스 알고리즘 맥락에서 '하나의 값'은 시스템 내 모든 노드가 동의해야 하는 특정 데이터나 결정을 의미합니다.
이런 합의는 시스템 일관성을 유지하고 신뢰성을 확보하는 데 매우 중요합니다.

**팩소스 알고리즘의 핵심 포인트**

- 제안자(proposer): 제안자는 합의 프로세스를 시작하는 역할을 하는 노드. 제안자는 합의해야할 값을 제안하고,
  이 제안을 시스템 내 다른 노드에 전파합니다.
- 수용자(acceptor): 수용자는 제안자에게서 제안을 받고, 제안이 수용되었는지 다른 노드에 알립니다.
- 학습자(learner): 학습자는 합의된 값을 최종적으로 받는 노드입니다. 합의한 후 학습자는 이 값을 확보하고
  이를 기반으로 후속 작업을 수행합니다.

#### 3.2.2 래프트(Raft) 알고리즘

래프트는 분산 시스템에 장애가 발생하더라도 하나의 일관된 상태에 합의할 수 있도록 하는 것이 목표입니다.
이를 위해 하나의 합의 문제를 리더 선출, 로그 복제, 안정성이라는 하위 문제 세 개로 나눕니다.
이런 하위 문제를 하나씩 해결함으로써 각 노드 간 소통과 통신을 간소화하여 합의에 쉽게 도달할 수 있도록 합니다.
래프트는 팩소스와 달리 지정된 '리더'가 있다는 점에서 차이가 있습니다.

**래프트 알고리즘의 구성 요소**

- **Leader**
    - 클러스터의 단일 쓰기/조정자
    - 클라이언트 요청 처리 및 로그 복제 주도
    - 주기적 하트비트(AppendEntries RPC) 전송
- **Follower**
    - 기본 상태
    - 리더의 로그 복제/하트비트를 수신
    - 리더의 Heartbeat를 타임아웃 발생 시 Candidate로 전환
- **Candidate**
    - 선거(Election) 시작
    - 다른 노드에 투표 요청(RequestVote RPC)
    - 과반 득표 시 Leader로 승격, 실패/동률/상위 term 수신 시 Follower로 복귀

> **비잔티움 장군 문제**
> 비잔티움 장군 문제는 “거짓말하는 노드까지 있는 상황에서의 합의 문제”이며,
> 일반 DB/클러스터는 보통 이를 가정하지 않는다.

### 3.5 일관된 해싱

데이터를 여러 노드에 효율적으로 분배하면서 노드를 추가하거나 삭제할 때
데이터 위치를 다른 곳으로 옮겨야 하는 과정이 최소화되도록 하는 방식입니다.

노드를 추가하거나 삭제하면 데이터 키를 노드에 매핑하는 해시 함수가 변경되므로 데이터를 다시 매핑하고 재분배해야 합니다.

일관된 해싱이 해결하고자 하는 주요 문제는 분산 시스템의 확장성과 장애 허용성입니다.
이 기법은 시스템의 노드를 추가하거나 제거할 때 전체 데이터를 다시 매핑하지 않고 일부 데이터만 이동하도록 하여
영향을 최소화하는 것이 목표입니다.

## 시스템 구성 요소 설계 및 구현

### 요청 속도 제안

- 토큰 버킷 알고리즘: 입구에서 조절
- 누수 버킷 알고리즘: 입구에서 조절 및 초당 처리되는 양이 일정하게 만들 때
- 슬라이딩 윈도우 알고리즘: 최근 60초 동안 최대 100 요청

### 중앙 집중형 로깅

- 발생 시각
- 서비스 이름
- 로그 레벨
- 메시지
- 추가 정보: 사용자 ID, 트랜잭션 ID 등 이벤트와 관련된 세부 정보

**모범 사례**

- 일관된 로그 형식 사용하기
- 로그에 컨텍스트 정보 포함하기
    - 사용자 ID
    - 트랜잭션 ID
- 예외를 적절하게 처리하기
    - 스택 트레이스를 포함하여 로그를 남김 (줄바꿈 주의)

### 메트릭

메트릭은 시스템의 상태와 성능을 수치로 표현합니다.
이것으로 시스템 확장, 성능 개선, 문제 해결의 실마리를 얻을 수 있기도 합니다.

**메트릭 종류**

- 시스템 메트릭: CPU 사용량, 메모리 사용량, 디스크 입출력, 네트워크 입출력
- 애플리케이션 메트릭: 요청 속도, 오류 비율, 응답 시간 등
- 비즈니스 메트릭: 사용자 가입 수, 주문 건수등이 포함

**모범 사례**

- 핵심 메트릭 선정하기
- 일관된 이름 규칙 사용하기
- 오류율과 지연 시간 모니터링
- 메트릭 시각화

### 알림

알림을 설계할 때 다음 내용을 고려해야 합니다.

- 중요도: 모든 알림이 동일한 우선순위를 가지는 것은 아닙니다.
  예를 들어, 긴급 알림은 즉작적으로 조치해야 하지만, 경고 수준의 알림은 근무 시간 내 처리해도 괜찮은 경우가 있습니다.
- 실행 가능성: 알림은 실제로 필요한 경우에만 만들어야 합니다.
  아무런 조치가 필요하지 않은 알림이라면 굳이 생성할 필요가 없습니다.
- 문제를 파악할 수 있는 정보: 알림에는 문제를 진단하는 데 필요한 정보가 충분히 포함되어야 합니다.
  예를 들어 어떤 서비스에 문제가 발생했는지, 발생 시간은 언제인지, 관련된 오류 메시지나 로그는 무엇인지 등
  명확히 전달해야 합니다.

**모범 사례**

- 알림을 너무 많이 발생시키지 말 것
- 알림을 테스트 할 것: 의도한 대로 작동하는지 주기적으로 확인해야 합니다. 카오스 엔지니어링[^3] 실험을 진행하거나 정기적인 테스트 과정에서
  점검하는 것이 좋습니다.
- 알림 프로세스를 문서화할 것: 각 알림 유형에 어떻게 대응해야 하는지 문서로 정리해야 합니다.
  여기에는 문제 해결 절차, 누구에게 상황을 전달해야 하는지, 관련된 실행 지침이 들어갈 수 있습니다.

### 분산 시스템의 트레이싱

요청이 각 단계를 스팬으로 기록하며, 스팬이 모여 요청 전체의 흐름을 보여 주는 트레이스를 구성합니다.

- 성능 최적화: 요청 흐름을 시각화하면 성능 병목 현상을 파악하고 이를 최적화할 수 있습니다.
- 오류 진단: 요청이 실패한 경우 트레이스를 활용하여 오류가 발생한 위치와 원인을 파악할 수 있습니다.
- 시스템 동작 파악: 트레이싱을 활용하면 시스템에서 요청이 처리되는 흐름을 명확히 파악할 수 있습니다.
  덕분에 새로운 팀원이 시스템 구조를 빠르게 이해할 수 있고, 시스템 설정이나 아키텍처를 변경할 게획이 있을 떄
  유용하게 사용할 수 있습니다.

## URL 단축 서비스 설계

---

[^1]:
    일관성 (Consistency), 가용성 (Availability), 파티션 허용성 (Partition tolerance)의 앞
    글자를 합치면 CAP가 됩니다.

[^2]: 발음은 pass-elk(패스-엘크)로 합니다.

[^3]:
    시스템의 복원력과 안정성을 테스트하려고 의도적으로 장애를 유발하는 실험 기범입니다.
    시스템이 예상치 못한 상황에서도 얼마나 잘 대처할 수 있는지 확인하고 개선점을 찾을 수 있습니다.
