# Go 소개

Go는 빠른 컴파일, 단순한 툴체인, 동시성 친화성을 목표로 설계된 언어입니다. 서버 및 인프라 개발에서 생산성과 성능의 균형을 노립니다.

## 컴파일과 툴체인

- 엄격한 컴파일 규칙: 사용하지 않는 변수/임포트는 경고가 아니라 오류로 처리됩니다.
- 단순한 컴파일러 구조: Go 전용 프론트엔드와 SSA 기반 최적화, 전용 어셈블러/링커로 구성됩니다.
- 기본 빌드 과정에서 텍스트 어셈블리 파일을 생성하지 않으며, 필요할 때만 `go tool compile -S`로 확인합니다.

**LLVM 기반 컴파일러와 비교(개념적)**

| 비교 항목  | LLVM 기반 (C, C++, Rust 등)        | Go 컴파일러                                |
| :--------- | :--------------------------------- | :----------------------------------------- |
| 프론트엔드 | 언어별 구문 분석 후 LLVM IR 생성   | Go 소스 분석 후 SSA 변환                   |
| 최적화     | 공통 최적화 패스 다수              | Go 특화 SSA 최적화 + 코드 생성 단계 최적화 |
| 백엔드     | LLVM 백엔드가 타겟 아키텍처로 변환 | 전용 어셈블러/링커가 객체/바이너리 생성    |
| 복잡도     | 매우 높음                          | 상대적으로 낮음                            |

**SSA와 코드 생성 단계 최적화**

Go 최적화는 SSA 변환 이후의 최적화와 코드 생성 단계에서 이루어지며, 레지스터 할당/명령 선택 같은 하드웨어 근접 최적화를 수행합니다.

## 동시성 모델

- 고루틴(Goroutine)과 채널(Channel)을 기본 동시성 구성 요소로 제공합니다.
- 런타임 스케줄러가 M:N 모델로 고루틴을 OS 스레드에 매핑합니다.
- `GOMAXPROCS` 설정으로 실제 병렬 실행 수를 조절합니다.

## 표준 도구

- `go mod`로 의존성 및 버전 관리를 합니다.
- `gofmt`로 코드 포맷을 일관되게 유지합니다.
- `go test`, `go vet`으로 테스트 및 기본 정적 분석을 수행합니다.

## 메모리 관리

Go는 가비지 컬렉션(GC)을 채택합니다. 대표적인 메모리 관리 방식은 다음과 같습니다.

1. 관리하지 않기(Manual Management): C, C++ — 개발자가 직접 할당/해제
2. 가비지 컬렉션(GC): Go, Java, JavaScript/TypeScript — 런타임이 자동 회수
3. 자동 참조 카운팅(ARC): Swift, Objective-C — 참조 횟수 기반 해제
4. 컴파일 타임 오너십: Rust — 소유권 규칙으로 컴파일 타임 해제 결정

Go의 GC는 낮은 지연 시간과 병행 수행을 목표로 설계되었습니다.

## 설계 배경: 멀티코어 시대

- 단일 코어 성능 향상이 둔화되면서 동시성/병렬성이 중요해졌습니다.
- Go는 고루틴과 단순한 툴체인으로 멀티코어 시대의 요구에 대응합니다.
- 결과적으로 "생산성과 성능의 균형"을 목표로 한 언어 포지셔닝을 갖습니다.
